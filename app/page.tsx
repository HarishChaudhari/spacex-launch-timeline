"use client"
import styles from './page.module.css'
import { useEffect, useState } from 'react';

var timerInterval: any;
var rotationInterval: any;


export default function Home() {
    const [timeValue, setTimeValue] = useState('0.5');
    const [timerClock, setTimerClock] = useState('T - 00:00:00');
    const [is_started, setIsStarted] = useState(false);
    const [rotationAngle, setRotationAngle] = useState(0.1);

    function startLaunch() {
        if (is_started === true) {
            setIsStarted(false);
            clearInterval(timerInterval);
            clearInterval(rotationInterval);
        } else {
            setIsStarted(true);
            setTimer(timeValue, 'dec');

        }
    }
    function setAngle(e: any) {
        setRotationAngle(e.target.value);
    }

    function updateTimer(e: any) {
        clearInterval(timerInterval);
        clearInterval(rotationInterval);

        return setTimeValue(e.target.value);
    }

    function setTimer(input: any, mode: string) {
        clearInterval(timerInterval);
        let duration = input * 60;
        let timer = duration, hours, minutes, seconds;

        timerInterval = setInterval(function () {
            hours = Math.floor(timer / 3600);
            minutes = Math.floor(timer % 3600 / 60);
            seconds = Math.floor(timer % 3600 % 60);

            hours = hours < 10 ? "0" + hours : hours;
            minutes = minutes < 10 ? "0" + minutes : minutes;
            seconds = seconds < 10 ? "0" + seconds : seconds;

            let prefix = (mode === 'dec') ? "T - " : "T + ";
            setTimerClock(prefix + hours + ":" + minutes + ":" + seconds);

            timer = (mode === 'dec') ? --timer : ++timer;

            if (timer < 0) {
                // clear interval as we don't want to repeat the countdown.
                clearInterval(timerInterval);

                // generated by chatgpt3
                // let timestamps = [0.1, 7, 25, 40, 60, 65, 70, 85, 92, 95, 99];
                // plotNodesOnCircle(11, 100, 576, timestamps, 1152, 1152);

                startRotation();
                setTimer(0, 'inc');
            }

        }, 1000);
    };

    function elementsOverlap(el1: any, el2: any) {
        const domRect1 = el1.getBoundingClientRect();
        const domRect2 = el2.getBoundingClientRect();
        const min = -5; // offset

        return !(domRect1.left - min > domRect2.right);
    }
    function elementOutside(el1: any, el2: any) {
        const domRect1 = el1.getBoundingClientRect();
        const domRect2 = el2.getBoundingClientRect();
        const min = -5; // offset
        return (domRect1.top - min > domRect2.bottom + 200);
    }

    function startRotation() {
        clearInterval(rotationInterval);
        rotationInterval = setInterval(function () {
            //rotate the circle
            var angle = parseFloat(jQuery('#page_circle_wrapper__RmoWD').attr('data-angle') as string);
            angle = angle - rotationAngle;

            jQuery('#page_circle_wrapper__RmoWD').css('transform', 'rotate(' + angle + 'deg)');
            jQuery('#page_circle_wrapper__RmoWD').attr('data-angle', angle);

            jQuery('#nodes li').each(function () {

                if (elementsOverlap(jQuery(this).find('div')[0], jQuery('#page_marker__Y9t1D')[0]) === true) {
                    jQuery(this).addClass('page_done__0RB5C');
                }
                // check if element goes outside div remove done class
                if (elementOutside(jQuery(this).find('div')[0], jQuery('.page_timeline_wrapper__ybJhT')[0]) === true) {
                    jQuery(this).removeClass('page_done__0RB5C');
                }
            });
        }, 100);
    }

    function plotNodesOnCircle(n: any, d: any, r: any, timestamps: any, width: any, height: any) {
        // Get a reference to the <canvas> element.
        let canvas = document.getElementById('page_myCanvas__8Xiqg');
        
        if( canvas !== null ) {
            // Get a reference to the 2D drawing context of the <canvas> element.
            // @ts-ignore: Property 'getContext' does not exist on type 'HTMLElement'.
            let ctx = canvas.getContext('2d');
            
            // Calculate the coordinates of the center of the circle.
            let centerX = (width / 2);
            let centerY = (height / 2) + 24;

            // Save the current canvas transformation.
            ctx.save();

            // Rotate the canvas by 180 degrees.
            ctx.translate(centerX, centerY);
            ctx.rotate(Math.PI);

            // Draw a circle with radius r on the <canvas> element.
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, 2 * Math.PI);
            ctx.strokeStyle = '#ffffff';
            ctx.stroke();

            // For each node i in the range 1 to n, do the following:
            for (let i = 1; i <= n; i++) {
                // Get the timestamp of the node i from the array of timestamps.
                let t_i = timestamps[i - 1];

                // Generate a random color for the node.
                //let color = '#' + Math.floor(Math.random() * 16777215).toString(16);
                let color = '#ffffff';

                // Calculate the angle of the point on the circle that corresponds to the timestamp t_i.
                let angle_i = 2 * Math.PI * t_i / d + Math.PI / 2;

                // Calculate the coordinates of the point on the circle that corresponds to the angle angle_i.
                let x_i = r * Math.cos(angle_i);
                let y_i = r * Math.sin(angle_i);

                // Draw a hollow circle at the coordinates (x_i, y_i) with the generated color.
                ctx.beginPath();
                ctx.arc(x_i, y_i, 5, 0, 2 * Math.PI);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = '#000000';
                ctx.fill();

                // Save the current canvas transformation.
                ctx.save();



                // Draw a white background circle at the coordinates (x_i, y_i) with the generated color.
                ctx.beginPath();
                ctx.arc(x_i, y_i, 2, 0, 2 * Math.PI);
                ctx.fillStyle = '#ffffff';
                ctx.fill();

                ctx.save();

                // Translate the canvas to the center of the node and rotate it to match the angle of the point on the circle.
                ctx.translate(x_i, y_i);
                ctx.rotate(angle_i + Math.PI / 2);


                // Draw a small white line on top of the node name.
                ctx.beginPath();
                if ((n % 2 !== 0) && (i === n)) {
                    ctx.moveTo(0, -6);
                    ctx.lineTo(0, -10);
                } else if (i % 2 === 0) {
                    ctx.moveTo(0, -6);
                    ctx.lineTo(0, -10);
                } else {
                    ctx.moveTo(0, 6);
                    ctx.lineTo(0, 10);
                }
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Calculate the width of the node name in pixels.
                let nodeNameWidth = ctx.measureText(`Node ${i}`).width;


                // Draw the name of the node to the left of the node.
                ctx.fillStyle = color;
                ctx.font = '12px sans-serif';
                if ((n % 2 !== 0) && (i === n)) {
                    ctx.fillText(`Node ${i}`, -nodeNameWidth / 2 - 3, -15);
                } else if (i % 2 === 0) {
                    ctx.fillText(`Node ${i}`, -nodeNameWidth / 2 - 3, -15);
                } else {
                    ctx.fillText(`Node ${i}`, -nodeNameWidth / 2 - 3, 25);
                }
                // Restore the previous canvas transformation.
                ctx.restore();
            }

            // Restore the previous canvas transformation.
            ctx.restore();
        }
    }

    function plotNodesOnCircle2(n: any, d: any, r: any, timestamps: any, width: any, height: any) {
        // Get a reference to the <svg> element.
        let svg = document.getElementById('page_mySvg__NvADY');

        if (svg !== null) {
            // Calculate the coordinates of the center of the circle.
            let centerX = (width / 2);
            let centerY = (height / 2);

            // Create an SVG circle element with radius r at the center of the canvas.
            let circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', centerX.toString());
            circle.setAttribute('cy', centerY.toString());
            circle.setAttribute('r', r.toString());
            circle.setAttribute('stroke', '#ffffff');
            svg.appendChild(circle);

            // For each node i in the range 1 to n, do the following:
            for (let i = 1; i <= n; i++) {
                // Get the timestamp of the node i from the array of timestamps.
                let t_i = timestamps[i - 1];

                // Generate a random color for the node.
                //let color = '#' + Math.floor(Math.random() * 16777215).toString(16);
                let color = '#ffffff';

                // Calculate the angle of the point on the circle that corresponds to the timestamp t_i.
                let angle_i = 2 * Math.PI * t_i / d + Math.PI / 2;

                // Calculate the coordinates of the point on the circle that corresponds to the angle angle_i.
                let x_i = r * Math.cos(angle_i);
                let y_i = r * Math.sin(angle_i);

                // Create an SVG circle element for the node at the coordinates (x_i, y_i) with the generated color.
                let node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                node.setAttribute('cx', (centerX + x_i).toString());
                node.setAttribute('cy', (centerY + y_i).toString());
                node.setAttribute('r', '5');
                node.setAttribute('stroke', color);
                node.setAttribute('stroke-width', '1');
                node.setAttribute('fill', '#000000');
                svg.appendChild(node);

                // Create a small white circle for the node name.
                let nameCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                nameCircle.setAttribute('cx', (centerX + x_i).toString());
                nameCircle.setAttribute('cy', (centerY + y_i).toString());
                nameCircle.setAttribute('r', '2');
                nameCircle.setAttribute('fill', '#ffffff');
                
                svg.appendChild(nameCircle);

                // Create an SVG text element for the node name.
                let name = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                
                if ((n % 2 !== 0) && (i === n)) {
                    name.setAttribute('x', (centerX + x_i).toString());
                    name.setAttribute('y', (centerY + y_i - 15).toString());
                } else if (i % 2 === 0) {
                    name.setAttribute('x', (centerX + x_i).toString());
                    name.setAttribute('y', (centerY + y_i - 15).toString());
                } else {
                    name.setAttribute('x', (centerX + x_i).toString());
                    name.setAttribute('y', (centerY + y_i + 25).toString());
                }
                name.setAttribute('transform', `rotate(${(angle_i + Math.PI / 2) * 180 / Math.PI}, ${centerX + x_i}, ${centerY + y_i})`);
                name.setAttribute('fill', color);
                name.setAttribute('font-size', '10');
                name.setAttribute('text-anchor', 'middle');
                name.innerHTML = `Node ${i}`;
                svg.appendChild(name);

                // Create a small white line on top of the node name.
                let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                
                if ((n % 2 !== 0) && (i === n)) {
                    line.setAttribute('x1', (centerX + x_i).toString());
                    line.setAttribute('y1', (centerY + y_i - 6).toString());

                    line.setAttribute('x2', (centerX + x_i).toString());
                    line.setAttribute('y2', (centerY + y_i - 10).toString());
                } else if (i % 2 === 0) {
                    line.setAttribute('x1', (centerX + x_i).toString());
                    line.setAttribute('y1', (centerY + y_i - 6).toString());

                    line.setAttribute('x2', (centerX + x_i).toString());
                    line.setAttribute('y2', (centerY + y_i - 10).toString());
                } else {
                    line.setAttribute('x1', (centerX + x_i).toString());
                    line.setAttribute('y1', (centerY + y_i + 6).toString());

                    line.setAttribute('x2', (centerX + x_i).toString());
                    line.setAttribute('y2', (centerY + y_i + 10).toString());
                }
                line.setAttribute('transform', `rotate(${(angle_i + Math.PI / 2) * 180 / Math.PI}, ${centerX + x_i}, ${centerY + y_i})`);
                line.setAttribute('stroke', '#ffffff');
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);
            }
        }
    }

    useEffect(() => {

        // You now have access to `window`
        let timestamps = [0.1, 7, 25, 40, 60, 65, 70, 85, 92, 95, 99];
        plotNodesOnCircle2(11, 100, 576, timestamps, 1200, 1200);

    }, []);

    return (
        <div className={styles.container}>
            <main className={styles.main}>
                <div className={styles.grid}>
                    <a className={styles.card}>
                        <h2>Start/Stop</h2>
                        <p>
                            <button className={styles.button} onClick={startLaunch}>
                                {is_started === false ? "Start" : "Stop"}
                            </button>
                        </p>
                    </a>

                    <a className={styles.card}>
                        <h2>Time to Lanuch &rarr;</h2>
                        <p>
                            <input className={styles.input_text}
                                value={timeValue}
                                onChange={updateTimer}
                            />
                            In Minutes.</p>
                    </a>

                    <a className={styles.card}>
                        <h2>Rotation Angle &rarr;</h2>
                        <p>
                            <input className={styles.input_text}
                                value={rotationAngle}
                                onChange={setAngle}
                            />
                            In degrees.
                        </p>
                    </a>
                </div>

                <div className={styles.timeline_wrapper}>
                    <div id={styles.marker}></div>
                    <div id={styles.circle_wrapper} data-angle="0">
                        <div id={styles.circle}></div>
                        <ul id="nodes" className={styles.nodes}>
                            <li data-current-x="0" data-current-y="0"><div className={styles.node_circle}></div><span>Startup</span></li>
                            <li data-current-x="40" data-current-y="6"><div className={styles.node_circle}></div><span>Liftoff</span></li>
                            <li data-current-x="77" data-current-y="22"><div className={styles.node_circle}></div><span>Max Q</span></li>
                            <li data-current-x="125" data-current-y="57"><div className={styles.node_circle}></div><span>MECO</span></li>
                            <li data-current-x="165" data-current-y="114"><div className={styles.node_circle}></div><span>S1 Detach</span></li>
                            <li data-current-x="172" data-current-y="198"><div className={styles.node_circle}></div><span>S2 Startup</span></li>
                            <li data-current-x="150" data-current-y="261"><div className={styles.node_circle}></div><span>SECO</span></li>
                            <li data-current-x="180" data-current-y="412"><div className={styles.node_circle}></div><span>Deploy</span></li>
                        </ul>
                    </div>

                    <div className={styles.timer_clock}>{timerClock}</div>
                </div>
                <div className={styles.canvas_wrapper}>
                    {/* <canvas id={styles.myCanvas} width="1200" height="1200"></canvas> */}
                    <svg id={styles.mySvg} width="1200" height="1200"></svg>
                </div>
                <div>
                    <p className={styles.fun}>Made just for fun!</p>
                    <p className={styles.fun_desc}>I could have made it a lot better, but I think this is good enough to play with. :)
                        <br />Besides, I was just experimenting with <a href="https://nextjs.org/blog/next-13" target="_blank" rel="noreferrer">Next.js 13</a> and wanted a cool idea with smaller interactions.
                        <br />This is desktop only, did not have enough time to make it work on different screens.
                        If an algorithm is devised for plotting the nodes based on the actual mission time, then a whole lot of other features such as zoom in/out the timeline and few more interations can be added.
                    </p>
                </div>
            </main>
        </div>
    )
}